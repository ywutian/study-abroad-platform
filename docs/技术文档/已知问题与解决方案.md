# 已知问题与解决方案

## 目录

1. [Next.js 16 Turbopack 路由组兼容性](#1-nextjs-16-turbopack-路由组兼容性)
2. [Prisma Schema 漂移](#2-prisma-schema-漂移)
3. [React Hydration 警告](#3-react-hydration-警告)
4. [单元测试 DI Mock 缺失](#4-单元测试-di-mock-缺失)
5. [学校库前端数据显示](#5-学校库前端数据显示)
6. [pgvector 反序列化错误](#6-pgvector-反序列化错误)
7. [预测概率相同问题](#7-预测概率相同问题)

---

## 1. Next.js 16 Turbopack 路由组兼容性

### 问题描述

**严重程度**: P0 Critical
**状态**: ✅ 已修复 (2026-02-07)

Next.js 16（当前版本 16.1.6）的 Turbopack 编译器在处理路由组 (`(main)`, `(auth)`) 时存在兼容性问题。所有位于路由组内的页面在 Turbopack 模式下返回 404，但在 Webpack 模式下正常工作。该问题最初在 16.1.3 版本上发现。

### 根因

`middleware.ts` 中的旧 matcher 配置 `['/', '/(zh|en)/:path*']` 在 Turbopack 的路由解析逻辑下无法正确匹配路由组内的路径。Turbopack 对路由组的处理方式与 Webpack 不同。

### 解决方案

#### 1. 更新 middleware matcher（核心修复）

```typescript
// apps/web/src/middleware.ts
export const config = {
  // 排除式匹配：匹配所有路径（排除静态资源和 API）
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)',
  ],
};
```

**原理**：使用排除式（负向前瞻）模式替代包含式匹配，避免了 Turbopack 在解析路由组路径时的歧义。

#### 2. 开发脚本安全网

```json
// apps/web/package.json
{
  "dev": "next dev",
  "dev:webpack": "next dev --webpack"
}
```

**说明**：默认使用 Turbopack 编译器（Next.js 16 默认），`dev:webpack` 提供 Webpack 回退选项。

### 验证方法

```bash
# 验证 Turbopack 模式（默认）
pnpm --filter web dev
# 访问 http://localhost:3000/zh/dashboard 应返回 200

# 验证 Webpack 模式（回退）
pnpm --filter web dev:webpack
# 同样应返回 200
```

---

## 2. Prisma Schema 漂移

### 问题描述

**严重程度**: P2 Medium
**状态**: ✅ 已修复 (2026-02-07)

在开发过程中使用 `prisma db push` 快速同步了 `Competition` 模型和 `Award.competitionId` 列，但未创建对应的迁移文件。这导致数据库已是最新状态，但 `_prisma_migrations` 表缺少记录。

### 根因

- 开发阶段频繁使用 `prisma db push` 进行快速迭代
- 旧迁移历史不可重放（shadow database 无法从零开始应用全部迁移）
- `migration_lock.toml` 缺失

### 解决方案

1. 创建 `migration_lock.toml` 文件
2. 使用 `prisma migrate diff` 确认数据库已同步
3. 手动创建迁移 SQL 文件
4. 使用 `prisma migrate resolve --applied` 标记为已应用

详细步骤见 [数据库迁移记录.md](数据库迁移记录.md)。

### 预防措施

- 新功能开发时优先使用 `prisma migrate dev --create-only` 生成迁移
- 生产部署使用 `prisma migrate deploy`
- 定期执行 `prisma migrate status` 检查同步状态

---

## 3. React Hydration 警告

### 问题描述

**严重程度**: P3 Low
**状态**: ✅ 已修复 (2026-02-07)

多个前端组件在服务端渲染（SSR）和客户端渲染（CSR）之间产生不一致，触发 React Hydration 警告。

### 常见原因

1. **浏览器 API 在 SSR 中执行** — `window.location`, `navigator.language`, `window.innerWidth`
2. **时间相关计算** — `new Date()` 在服务端和客户端产生不同值
3. **动态内容** — 基于客户端状态的条件渲染

### 已修复的组件

| 组件                 | 问题                                                                            | 修复方式                                       |
| -------------------- | ------------------------------------------------------------------------------- | ---------------------------------------------- |
| `app/not-found.tsx`  | `window.location.pathname` 和 `navigator.language` 在 `useState` 初始化器中执行 | 移入 `useEffect`                               |
| `DailyChallenge.tsx` | `new Date()` 计算剩余时间在 SSR/CSR 不一致                                      | `useState(0)` + `useEffect` + `setInterval`    |
| `virtual-list.tsx`   | `window.innerWidth` 在 `useMemo` 中执行                                         | `useState(默认值)` + `useEffect` + resize 监听 |

### 修复模式

#### 模式 A：浏览器 API 延迟执行

```tsx
// 错误 ❌
const [locale, setLocale] = useState(window.location.pathname.startsWith('/zh') ? 'zh' : 'en');

// 正确 ✅
const [locale, setLocale] = useState('en'); // SSR 安全默认值
useEffect(() => {
  if (window.location.pathname.startsWith('/zh')) setLocale('zh');
}, []);
```

#### 模式 B：时间计算延迟执行

```tsx
// 错误 ❌
const hours = Math.floor((midnight - Date.now()) / 3600000);

// 正确 ✅
const [timeLeft, setTimeLeft] = useState({ hours: 0, minutes: 0 });
useEffect(() => {
  const update = () => {
    /* calculate */ setTimeLeft({ hours, minutes });
  };
  update();
  const interval = setInterval(update, 60000);
  return () => clearInterval(interval);
}, []);
```

#### 模式 C：响应式值延迟计算

```tsx
// 错误 ❌
const columns = useMemo(() => {
  const width = window.innerWidth;
  return width >= 1024 ? 3 : 2;
}, []);

// 正确 ✅
const [columns, setColumns] = useState(2); // SSR 安全默认值
useEffect(() => {
  const update = () => setColumns(window.innerWidth >= 1024 ? 3 : 2);
  update();
  window.addEventListener('resize', update);
  return () => window.removeEventListener('resize', update);
}, []);
```

---

## 4. 单元测试 DI Mock 缺失

### 问题描述

**严重程度**: P2 Medium
**状态**: ✅ 已修复 (2026-02-07)

9 个 Jest 测试套件因 NestJS 依赖注入（DI）配置不完整而失败。主要原因是服务构造函数新增了依赖，但对应的测试文件未更新 mock provider。

### 通用修复方法

```typescript
// 1. 查看服务构造函数的依赖
constructor(
  private readonly prisma: PrismaService,
  private readonly memory: MemoryManagerService, // 新增的依赖
) {}

// 2. 在 spec 文件的 providers 中添加对应 mock
{
  provide: MemoryManagerService,
  useValue: {
    remember: jest.fn().mockResolvedValue(undefined),
    recall: jest.fn().mockResolvedValue([]),
  },
}
```

### 关键经验

1. **Mock 方法名必须与实际服务一致** — 例如 `RedisCacheService` 的 `cacheMessage` 而非 `addMessage`
2. **可选依赖也需要 mock** — 使用 `@Optional()` 注入的依赖如 `MemoryScorerService`
3. **返回值类型要正确** — `getMessages` 必须返回数组而非 `undefined`，否则 `for...of` 会抛出 `messages is not iterable`
4. **架构变更后及时更新测试** — `AgentRunnerService` 改为依赖 `WorkflowEngineService` 后，测试需同步重构

---

## 5. 学校库前端数据显示

### 问题描述

**严重程度**: P2 Medium
**状态**: ⚠️ 待验证

API 返回 153 所学校数据，但前端 schools 页面显示 0 所。可能原因是分页参数名称不匹配（前端发送 `limit` 而后端 DTO 使用 `take`）。

### 调试步骤

1. 启动完整服务（API + Web + Docker services）
2. 访问 `/zh/schools` 页面
3. 打开浏览器 DevTools > Console
4. 查看 `[Schools] Failed to fetch schools:` 错误日志（已添加）
5. 检查 Network 面板中的请求参数和响应

### 可能的修复方向

- 前端分页参数与后端 `SchoolQueryDto` 对齐
- 检查 `@tanstack/react-query` 的 `queryFn` 是否正确解析 `response.data`

---

## 6. pgvector 反序列化错误

### 问题描述

**严重程度**: P1 Critical
**状态**: ✅ 已解决 (2026-02-09)

Prisma `$queryRaw` 使用 `SELECT *` 或 `RETURNING *` 时，如果表中包含 `vector` 类型列（如 `Memory.embedding`），Prisma 无法反序列化该类型，抛出 `Failed to deserialize column of type 'vector'`。

### 根因分析

- `Memory` 表有 `embedding Vector(1536)` 列
- `Entity` 表**没有** `embedding` 列，但早期代码错误地在 raw SQL 中引用了不存在的 `embedding` 列

### 解决方案

1. **Memory 表**: 所有 raw SQL 查询显式列出所需列（排除 `embedding`），包括 `persistent-memory.service.ts` 中的 7 处查询和 `memory-conflict.service.ts` 中的 1 处查询
2. **Entity 表**: 将 `upsertEntity` 和 `searchEntities` 从 raw SQL 改为 Prisma ORM 方法，完全避免 raw SQL

### 受影响文件

- `apps/api/src/modules/ai-agent/memory/persistent-memory.service.ts`
- `apps/api/src/modules/ai-agent/memory/memory-conflict.service.ts`

---

## 7. 预测概率相同问题

### 问题描述

**严重程度**: P1 High
**状态**: ✅ 已解决 (2026-02-09)

所有学校（如 MIT vs Boston College）返回相同的 ~35% 录取概率。

### 根因分析

1. AI Prompt 模板中包含 `probability: 0.35` 的示例，导致 AI 锚定
2. 没有统计基线作为校准参考
3. 单引擎架构，AI 失败时无 fallback

### 解决方案

升级为 v2 多引擎融合架构（ADR-0008）：

1. 移除 prompt 中的硬编码示例概率
2. 将统计引擎计算的 baseline 注入 AI prompt 作为校准锚点
3. AI 输出后处理：clamp 到 [0.05, 0.95]，偏差不超过统计 baseline 的 3 倍
4. 三引擎动态加权融合

### 详细文档

- [PREDICTION_SYSTEM.md](/docs/PREDICTION_SYSTEM.md)
- [ADR-0008](/docs/adr/0008-prediction-multi-engine-ensemble.md)
