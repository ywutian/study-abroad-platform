name: Deploy

on:
  workflow_run:
    workflows: ['CI']
    branches: [main]
    types: [completed]

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false # Never cancel in-progress deployments

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '10'

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    environment: staging
    outputs:
      api_url: ${{ steps.deploy-api.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm --filter api exec prisma generate

      - name: Run database migrations
        continue-on-error: true
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "DATABASE_URL not set, skipping migrations (handled by Railway)"
            exit 0
          fi
          pnpm --filter api exec prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Deploy API
        id: deploy-api
        run: |
          echo "API deployment is handled by Railway (auto-deploy on push)"
          echo "url=${{ vars.STAGING_API_URL || 'https://staging-api.study-abroad-platform.com' }}" >> $GITHUB_OUTPUT

      - name: Deploy Web to Vercel
        continue-on-error: true
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: apps/web
          vercel-args: '--prod'

  smoke-test:
    name: Staging Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    # Smoke tests are informational â€” don't block production deploy if staging URL isn't configured
    continue-on-error: true
    steps:
      - name: Check if staging URL is configured
        id: check-url
        run: |
          API_URL="${{ needs.deploy-staging.outputs.api_url || vars.STAGING_API_URL || '' }}"
          if [ -z "$API_URL" ]; then
            echo "No staging URL configured, skipping smoke tests"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Testing against: $API_URL"
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          fi

      - name: Wait for deployment to stabilize
        if: steps.check-url.outputs.skip != 'true'
        run: sleep 15

      - name: Health check
        if: steps.check-url.outputs.skip != 'true'
        run: |
          API_URL="${{ steps.check-url.outputs.api_url }}"
          echo "Testing health endpoint: ${API_URL}/health"

          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${API_URL}/health" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "::warning::Health check failed with status $STATUS"
            exit 1
          fi
          echo "Health check passed (HTTP $STATUS)"

      - name: Detailed health check
        if: steps.check-url.outputs.skip != 'true'
        continue-on-error: true
        run: |
          API_URL="${{ steps.check-url.outputs.api_url }}"
          RESPONSE=$(curl -s --max-time 30 "${API_URL}/health/detailed" || echo '{}')
          echo "Detailed health: $RESPONSE"

          DB_STATUS=$(echo "$RESPONSE" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('checks',{}).get('database',{}).get('status','unknown'))" 2>/dev/null || echo "unknown")
          if [ "$DB_STATUS" != "ok" ]; then
            echo "::warning::Database health check: $DB_STATUS"
          else
            echo "Database connectivity verified"
          fi

      - name: API readiness check
        if: steps.check-url.outputs.skip != 'true'
        continue-on-error: true
        run: |
          API_URL="${{ steps.check-url.outputs.api_url }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${API_URL}/health/ready" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "::warning::Readiness check returned status $STATUS"
          else
            echo "Readiness check passed"
          fi

      - name: Public endpoint smoke test
        if: steps.check-url.outputs.skip != 'true'
        continue-on-error: true
        run: |
          API_URL="${{ steps.check-url.outputs.api_url }}"

          # Test public schools endpoint
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${API_URL}/api/v1/schools?page=1&limit=1" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "::warning::Schools endpoint returned $STATUS (may need seeded data)"
          else
            echo "Schools endpoint passed"
          fi

          # Test auth endpoint reachability
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 -X POST "${API_URL}/api/v1/auth/login" -H "Content-Type: application/json" -d '{}' || echo "000")
          if [ "$STATUS" == "000" ]; then
            echo "::warning::Auth endpoint unreachable"
          else
            echo "Auth endpoint reachable (got $STATUS)"
          fi

      - name: Verify security headers
        if: steps.check-url.outputs.skip != 'true'
        continue-on-error: true
        run: |
          API_URL="${{ steps.check-url.outputs.api_url }}"
          HEADERS=$(curl -sI --max-time 30 "${API_URL}/health" || echo "")

          echo "$HEADERS" | grep -qi "x-content-type-options" && echo "x-content-type-options: present" || echo "::warning::Missing x-content-type-options header"
          echo "$HEADERS" | grep -qi "x-frame-options" && echo "x-frame-options: present" || echo "::warning::Missing x-frame-options header"
          echo "$HEADERS" | grep -qi "x-correlation-id" && echo "x-correlation-id: present" || echo "::warning::Missing x-correlation-id header"

  notify-staging:
    name: Notify Staging Result
    runs-on: ubuntu-latest
    needs: [deploy-staging, smoke-test]
    if: always()
    steps:
      - name: Notify Slack
        continue-on-error: true
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "${{ needs.smoke-test.result == 'success' && 'Staging deployment successful' || 'Staging deployment failed' }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*${{ needs.smoke-test.result == 'success' && 'Staging Deployment Successful' || 'Staging Deployment FAILED' }}*\n\nCommit: `${{ github.sha }}`\nBranch: `${{ github.ref_name }}`\nSmoke Tests: ${{ needs.smoke-test.result }}\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [smoke-test]
    if: always() && needs.smoke-test.result != 'cancelled'
    environment: production # Requires manual approval via GitHub Environment Protection Rules
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm --filter api exec prisma generate

      - name: Run database migrations
        continue-on-error: true
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "DATABASE_URL not set, skipping migrations (handled by Railway)"
            exit 0
          fi
          pnpm --filter api exec prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Deploy API
        run: |
          echo "API deployment is handled by Railway (auto-deploy on push)"
        env:
          GIT_COMMIT_SHA: ${{ github.sha }}
          BUILD_TIME: ${{ github.event.workflow_run.created_at }}

      - name: Deploy Web to Vercel Production
        continue-on-error: true
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: apps/web
          vercel-args: '--prod'

      - name: Create Sentry Release
        continue-on-error: true
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          environment: production
          version: api@${{ github.sha }}

      - name: Production health check
        continue-on-error: true
        run: |
          PROD_URL="${{ vars.PRODUCTION_API_URL || 'https://api.study-abroad-platform.com' }}"
          sleep 15
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${PROD_URL}/health" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "::warning::Production health check returned status $STATUS"
          else
            echo "Production health check passed"
          fi

      - name: Notify Slack on Production Deploy
        if: always()
        continue-on-error: true
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && 'Production deployment successful' || 'PRODUCTION DEPLOYMENT FAILED' }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*${{ job.status == 'success' && 'Production Deployment Successful' || 'PRODUCTION DEPLOYMENT FAILED' }}*\n\nCommit: `${{ github.sha }}`\nSentry Release: `api@${{ github.sha }}`\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
